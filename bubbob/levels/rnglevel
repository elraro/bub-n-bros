from random import *
from math import *

import boarddef
from boarddef import LNasty, LMonky, LGhosty, LFlappy
from boarddef import LSpringy, LOrcy, LGramy, LBlitzy
from boarddef import RNasty, RMonky, RGhosty, RFlappy
from boarddef import RSpringy, ROrcy, RGramy, RBlitzy

def flat(mean,var):
    return randrange(mean-var,mean+var+1)

def dice(n,sides,orig=1):
    result = 0
    for i in range(n):
        result += orig+randrange(sides)
    return result

def fish(mu):
    def fact(n):
        r = 1.
        for i in range(1,n+1):
            r *= i
        return r
    scale = fact(0)/exp(-mu)
    dens = []
    while 1:
        x = len(dens)
        dens.append(int(scale*exp(-mu)*pow(mu,x)/fact(x)+0.5))
        if x > mu and dens[-1] == 0:
            break
    table = []
    x = 0
    for d in dens:
        for i in range(d):
            table.append(x)
        x += 1
    return choice(table)


class RandomLevel(boarddef.Level):
    WIDTH  = 32
    HEIGHT = 28
    MAXTRY = 1000
    # parameters of the 'mess generator'
    # mess_prob : the probability that a cell turn into a wall

    def __init__(self,num):
        if hasattr(self.__class__, 'walls'):
            #print 'Reusing previously generated level'
            #print self.__class__.walls
            self.walls = self.__class__.walls
            boarddef.Level.__init__(self,num)
            return

        #print 'Generating a new level'
        self.reset(fill=False)

        self.windmap = [ [' ' for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]

        if hasattr(self, 'auto'):
            self.generate()
            self.do_bonuses()

        for gw in self.genwalls:
            gw[0](self,*gw[1:])

        if hasattr(self, 'mlist'):
            self.do_monsters()

        self.dig_vertical_walls()
        self.do_walls()
        self.walls = self.__class__.walls
        #print self.walls

        self.do_winds()
        self.winds = self.__class__.winds

        boarddef.Level.__init__(self,num)

    def reset(self, fill=False):
        if fill:
            w = '#'
            f = 0
        else:
            w = ' '
            f = 1
        # map for the walls
        self.wmap = [ [w for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        # map of the free cells
        self.fmap = [ [f for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]

    def setw(self,x,y,c='#'):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return
        if self.fmap[y][x]:
            self.wmap[y][x] = c
            self.fmap[y][x] = 0

    def getw(self,x,y):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return '#'
	return self.wmap[y][x]

    def clrw(self,x,y):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return
        self.wmap[y][x] = ' '
        self.fmap[y][x] = 1

    def lockw(self,x,y,c=0):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return
        self.fmap[y][x] = c

    def setwind(self,x,y,c=' '):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return
        self.windmap[y][x] = c

    def getwind(self,x,y):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return ' '
        return self.windmap[y][x]

    def mirror(self):
	"Mirror the level vertically."
	for y in range(self.HEIGHT):
	    for x in range(self.WIDTH/2):
		self.wmap[y][x] = self.wmap[y][self.WIDTH-x-1]

    def make_space(self, gens=-1):
        "Removes walls from a level, to make it more playable."
        if gens == -1:
            gens = randint(0,30)+1
        if gens & 1: # top
            for x in range(self.WIDTH):
                self.clrw(x,1)
                if random() < 0.5:
                    self.clrw(x,2)
        if gens & 2: # bottom
            for x in range(self.WIDTH):
                self.clrw(x,self.HEIGHT-1)
                if random() < 0.5:
                    self.clrw(x,self.HEIGHT-2)
        if gens & 4: # middle
            y = randint(0,self.HEIGHT/10) + (self.HEIGHT/2)
            for x in range(self.WIDTH):
                self.clrw(x,y)
                if random() < 0.5:
                    self.clrw(x,y-1)
                if random() < 0.5:
                    self.clrw(x,y+1)
        if gens & 8: # left and right
            x = randint(0,self.WIDTH/4)
            for y in range(self.HEIGHT):
                self.clrw(x,y)
                self.clrw(x+1,y)
                self.clrw(self.WIDTH-x,y)
                self.clrw(self.WIDTH-x-1,y)
        if gens & 16: # center
            for y in range(self.HEIGHT):
                self.clrw(self.WIDTH/2,y)
                self.clrw((self.WIDTH/2)-1,y)
                self.clrw((self.WIDTH/2)+1,y)

    def generate_wind1(self, rndchoice=1, choices=[' ',' ',' ','x','>','<','^','^','v'], xsize=-1,ysize=-1):
        """Makes a random wind pattern. Parameters:
        0: if 1=randomly select from choices, else select in order
        1: a list of the choices that are allowed.
        2: horizontal size of wind blocks
        3: vertical size of wind blocks
        """
        choicenum = 0
        if xsize == -1:
            xsize = randint(1, self.WIDTH)
        if ysize == -1:
            ysize = randint(1, self.HEIGHT)
        if xsize < 1:
            xsize = 1
        elif xsize > self.WIDTH:
            xsize = self.WIDTH
        if ysize < 1:
            ysize = 1
        elif ysize > self.HEIGHT:
            ysize = self.HEIGHT
        for x in range((self.WIDTH/xsize)+1):
            for y in range((self.HEIGHT/ysize)+1):
                if rndchoice == 1:
                    wdir = choice(choices)
                else:
                    wdir = choices[choicenum]
                    choicenum = (choicenum + 1) % len(choices)
                for dx in range(xsize+1):
                    for dy in range(ysize+1):
                        self.setwind(x*xsize+dx,y*ysize+dy,wdir)
        # make sure that the special bubbles can come into screen
        for x in range(self.WIDTH):
            self.setwind(x, 0, ' ')
            self.setwind(x, self.HEIGHT-1, ' ')

    def wind_sidewalls(self):
        """Make sure the left and side walls have updraft next to them
        """
        for y in range(self.HEIGHT):
            self.setwind(0,y,'^')
            self.setwind(self.WIDTH-1,y,'^')

    def generate_wind(self, gens = -1):
        """Chooses one of the wind pattern generators and uses that to generate the winds.
        0: choose what generator to use.
        """
        if gens == -1:
            gens = choice([1,1,2,3,4,4,4,4,5,6,7,8,9,10,11,12])
        if gens == 1: # totally random pattern
            self.generate_wind1()
        elif gens == 2: # wind "layers"
            self.generate_wind1(0, ['x','^','^','^'],self.WIDTH,1)
            self.wind_sidewalls()
        elif gens == 3: # "wiggly" winds
            self.generate_wind1(1, ['^','<','^','>'],1,1)
            self.wind_sidewalls()
        elif gens == 4: # "normal" wind pattern
            self.wind_sidewalls()
            dx = (self.WIDTH/2)
            if random() < 0.7:
                dy = 1 # usual height where bubbles collect
            else:
                dy = randint(1, self.HEIGHT-1)
            for x in range(dx-3, dx+3):
                self.setwind(x,dy,'x')
            for x in range(dx-2):
                self.setwind(x,dy,'>')
                self.setwind(self.WIDTH-x-1,dy,'<')
        elif gens == 5: # bubbles are stopped by horizontal walls
            self.wind_sidewalls()
            for x in range(self.WIDTH):
                for y in range(self.HEIGHT-2):
                    if self.getw(x,y) == '#':
                        if self.getw(x,y+1) == ' ':
                            self.setwind(x,y+1,'x')
        elif gens == 6: # bubbles move next the walls, rotating cw or ccw
            clockwise = choice([0,1])
            for x in range(self.WIDTH):
                for y in range(self.HEIGHT):
                    walld = 0
                    if self.getw(x,y) == '#':
                        walld = 16
		    else:
			if self.getw(x,y-1) == '#':
			    walld = walld + 1
			if self.getw(x+1,y) == '#':
			    walld = walld + 2
			if self.getw(x,y+1) == '#':
			    walld = walld + 4
			if self.getw(x-1,y) == '#':
			    walld = walld + 8
                    if clockwise:
                        #            0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
                        winddirs = [' ','>','v','v','<',' ','<','<','^','>',' ','v','^','>','^','x','x']
                    else:
                        winddirs = [' ','<','^','<','>',' ','^','<','v','v',' ','v','>','>','^','x','x']
                    wnd = winddirs[walld]
                    self.setwind(x,y,wnd)
        elif gens == 7: # bubbles move left and right whole level wide
            self.wind_sidewalls()
            ofs = choice([0,1])
            for x in range(self.WIDTH):
                for y in range(self.HEIGHT):
                    if (y+ofs) & 1:
                        self.setwind(x+1,y,'<')
                    else:
                        self.setwind(x-1,y,'>')
	elif gens == 8: # bubbles move towards the map centerline at random height
	    for x in range(self.WIDTH):
                y = randint(1, self.HEIGHT-1)
		if x < (self.WIDTH/2):
		    self.setwind(x,y,'>')
		else:
		    self.setwind(x,y,'<')
		self.setwind(x,0,'v')
		self.setwind(x,self.HEIGHT-1,'^')
	    for y in range(self.HEIGHT):
		self.setwind(self.WIDTH/2,y,'x')
	elif gens == 9: # bubbles move towards the side walls at random height
	    for x in range(self.WIDTH):
                y = randint(1, self.HEIGHT-1)
		if y & 1:
		    self.setwind(x,y,'>')
		else:
		    self.setwind(x,y,'<')
		self.setwind(x,0,'v')
		self.setwind(x,self.HEIGHT-1,'^')
	    for y in range(self.HEIGHT):
		self.setwind(0,y,'x')
		self.setwind(self.WIDTH-1,y,'x')
	elif gens == 10: # bubbles move up-down
	    ofs = choice([0,1])
	    dir_l = choice(['>', '>', '<'])
	    dir_r = choice(['<', '<', '>'])
	    for x in range(self.WIDTH):
		if x < (self.WIDTH / 2):
		    self.setwind(x, 0, dir_r)
		    self.setwind(x,self.HEIGHT-1,dir_l)
		else:
		    self.setwind(x, 0, dir_l)
		    self.setwind(x,self.HEIGHT-1,dir_r)
	    for x in range(self.WIDTH):
		for y in range(self.HEIGHT):
		    if (x+ofs) & 1:
			self.setwind(x,y+1,'^')
		    else:
			self.setwind(x,y-1,'v')
	elif gens == 11: # bubbles rotate
            self.wind_sidewalls()
	    for z in range(20):
		wid = randint(2,self.WIDTH/2)
		hei = randint(2,self.HEIGHT/2)
		y = randint(1, self.HEIGHT - hei - 1)
		x = randint(1, self.WIDTH - wid - 1)
		ok = 1
		for dx in range(wid):
		    if self.getwind(x+dx, y) != ' ':
			ok = 0
		    if self.getwind(x+dx, y+hei) != ' ':
			ok = 0
		for dy in range(hei):
		    if self.getwind(x, y+dy) != ' ':
			ok = 0
		    if self.getwind(x+wid, y+dy) != ' ':
			ok = 0
		if ok == 1:
		    if random() < 0.5: # ccw
			for dx in range(wid):
			    self.setwind(x+dx+1, y, '<')
			    self.setwind(x+dx, y+hei, '>')
			for dy in range(hei):
			    self.setwind(x, y+dy, 'v')
			    self.setwind(x+wid, y+dy+1, '^')
		    else: # cw
			for dx in range(wid):
			    self.setwind(x+dx, y, '>')
			    self.setwind(x+dx+1, y+hei, '<')
			for dy in range(hei):
			    self.setwind(x, y+dy+1, '^')
			    self.setwind(x+wid, y+dy, 'v')
	elif gens == 12: # bubbles gravitate towards a certain spot
	    dx = randint(1,self.WIDTH-1)
	    dy = randint(1,self.HEIGHT-1)
	    for x in range(self.WIDTH):
		for y in range(self.HEIGHT):
		    ax = abs(dx - x)
		    ay = abs(dy - y)
		    sx = cmp(dx - x, 0)
		    sy = cmp(dy - y, 0)
		    winds = [' ',' ',' ']
		    if ax < 2 and ay < 2:
			winds = ['x']
		    else:
			if sx < 0:
			    winds += ['<']
			elif sx > 0:
			    winds += ['>']
			else:
			    if sy > 0:
				winds = ['v']
			    elif sy < 0:
				winds = ['^']
			    else:
				winds = ['x']
			if sy < 0:
			    winds += ['^']
			elif sy > 0:
			    winds += ['v']
			else:
			    if sx > 0:
				winds = ['>']
			    elif sx < 0:
				winds = ['<']
			    else:
				winds = ['x']
		    self.setwind(x,y,choice(winds))

    def smooth(self, threshold, rev):
        """Remove wall blocks that are surrounded by 4 empty places.
        0: probability which a wall cell is turned into space
        1: smooth away walls or smooth away empty spaces?
        """
        # make a copy of self.wmap and adds '#' at the end of line, for
        # the overflowing indexing below: [x-1] and [x+1]
        tmpwmap = [ line + ['#'] for line in self.wmap ]
        if rev == 0:
            chr = ' '
        else:
            chr = '#'
        for x in range(self.WIDTH):
            for y in range(1,self.HEIGHT-1):
                count = 0
                if tmpwmap[y+1][x] == chr:
                    count = count + 1
                if tmpwmap[y-1][x] == chr:
                    count = count + 1
                if tmpwmap[y][x+1] == chr:
                    count = count + 1
                if tmpwmap[y][x-1] == chr:
                    count = count + 1
                if (count >= 4) and (random() < threshold):
                    if rev == 0:
                        self.clrw(x,y)
                    else:
                        self.setw(x,y)

    def mess(self, threshold):
        """Random fill of the board with walls.
        Only one argument, the probability that
        a cell turns out to be a wall.
        """
        for x in range(self.WIDTH):
            for y in range(self.HEIGHT):
                if random() < threshold:
                    self.setw(x,y)

    def zigzag_lr(self):
        """Generate the level with random left-right zig-zags.
        """
        first = 1
        self.reset(fill=False)
        y = choice([0,0,2,3,3,4])
        while y < (self.HEIGHT-2):
            if first == 1:
                first = 0
                x1 = x2 = randint(2, self.WIDTH-3)
            else:
                x2 = randint(2, self.WIDTH-3)
            while (x2 > (x1-3)) and (x2 < (x1+3)):
                x2 = randint(2, self.WIDTH-3)
            for dx in range(min(x1,x2+1), max(x1,x2+1)):
                self.setw(dx,y)
            dy = choice([2,2,3,3,3,4])
            for dy in range(dy+1):
                self.setw(x2,y+dy)
            y = y + dy
            x1 = x2

    def zigzag_ud(self):
        """Generate the level with random up-down zig-zags.
        """
        first = 1
        self.reset(fill=False)
        x = -1
        while x < self.WIDTH:
            if first == 1:
                first = 0
                y1 = y2 = randint(2, self.HEIGHT-1)
            else:
                y2 = randint(2, self.HEIGHT-1)
            while (y2 > (y1-2)) and (y2 < (y1+2)):
                y2 = randint(2, self.HEIGHT-1)
            for dy in range(min(y1,y2+1), max(y1,y2+1)):
                self.setw(x,dy)
            dx = choice([3,4,4,4,5,6])
            for dx in range(dx+1):
                self.setw(x+dx,y2)
            x = x + dx
            y1 = y2

    def zigzag(self):
        """Generate a level with a random zig-zag form.
        """
        if random() < 0.5:
            self.zigzag_lr()
        else:
            self.zigzag_ud()

    def platforms(self, (nplat, space), (rng_holes, rng_width), full=1):
        """Place random platforms.
        args is a tuple with the following fields:
        0: a tuple containing the number of platforms and
           the minum space between two platforms,
        1: a tuple indicating in order:
           - the rng for the number of holes per platform
           - the rng for the width of the holes,
        2: a flag indicating whether the platform should cross
           the whole level or not.
        """
        plat = []
        for i in range(nplat):
            ntry = 100
            while ntry:
                y = randint(0,self.HEIGHT-1)
                found = 0
                for old in plat:
                    if abs(old-y) <= space:
                        found = 1
                        break
                if not found:
                    plat.append(y)
                    break
                ntry -= 1
            if not ntry:
                continue  # ignore platform
            if full:
                x = 0
                w = self.WIDTH
            else:
                x = randint(0,self.WIDTH-1)
                w = randint(0,self.WIDTH-1)
                s = choice([-1,1])
                if s == -1:
                    w = min(w,x)
                    x -= w
                else:
                    w = min(w,self.WIDTH-x)
            for x1 in range(x,x+w):
                self.setw(x1,y)
            for i in range(rng_holes()):
                hx = randint(x,x+w)
                hw = rng_width()
                for h in range(hx-hw/2,hx+hw/2):
                    self.clrw(h,y)

    def discrete_blocks(self, blocks = -1):
	"""Put certain size blocks randomly, but so that they don't touch each other.
	"""
        self.reset(fill=False)
	if blocks == -1:
	    if random() < 0.75:
		blocks = [(4,2),(2,4)] # CompactLevels, level 16
		if random() < 0.30:
		    blocks.append((2,2))
		if random() < 0.20:
		    blocks.append((6,2))
		if random() < 0.10:
		    blocks.append((8,2))
	    else:
		blocks = []
		while len(blocks) == 0:
		    for bz in range(10):
			if random() < 0.3:
			    blocks.append((bz+1,1))
	ntry = 300
	while ntry:
	    ntry -= 1
	    doput = 1
	    block = choice(blocks)
	    wid = block[0]
	    hei = block[1]
	    x = randint(0,self.WIDTH-wid-2)
	    y = randint(1,self.HEIGHT-hei-3)
	    for dx in range(x,x+wid+2):
		for dy in range(y,y+hei+2):
		    if self.getw(dx,dy) == '#':
			doput = 0
	    if doput:
		for dx in range(x+1,x+wid+1):
		    for dy in range(y+1,y+hei+1):
			self.setw(dx,dy)

    def lines(self, rng_len, nlines, rng_angle=None):
        """Generate a set of lines in any direction. It takes three
        arguments, a rng for the length the lines, the number of lines,
        and a rng for the angle.
        """
        if rng_angle is None:
            rng_angle = lambda : choice([0]+[pi/i for i in range(3,21)]+[-pi/i for i in range(3,21)])
        for i in range(nlines):
            len = rng_len()
            angle = rng_angle()
            ntry = self.MAXTRY
            while ntry:
                sx = randint(0,self.WIDTH-1)
                sy = randint(0,self.HEIGHT-1)
                dx = int(sx + len*cos(angle) + 0.5)
                dy = int(sy + len*sin(angle) + 0.5)
                if dx < self.WIDTH and dy < self.HEIGHT and dx >= 0 and dy >= 0:
                    break
                ntry -= 1
            if ntry == 0:
                break
            if abs(dx-sx) > abs(dy-sy):
                for x in range(dx-sx+1):
                    y = (2*(dy-sy)*x/(dx-sx)+1)/2
                    self.setw(sx+x,sy+y)
            else:
                for y in range(dy-sy+1):
                    x = (2*(dx-sx)*y/(dy-sy)+1)/2
                    self.setw(sx+x,sy+y)

    def rooms(self, rng_radius, rng_e, n_rooms):
        """Generate rooms. It takes the following arguments:
        0: the rng for the radius of the room
        1: the rng for the excentricity of the room
        2: the number of rooms
        """
        for i in range(n_rooms):
            cx = randint(0,self.WIDTH-1)
            cy = randint(0,self.HEIGHT-1)
            r = rng_radius()
            e = rng_e()*1.0
            left   = cx-int(r*e+0.5)
            right  = cx+int(r*e+0.5)
            top    = cy-int(r/e+0.5)
            bottom = cy+int(r/e+0.5)
            for x in range(left,right+1):
                self.setw(x,top)
                self.setw(x,bottom)
            for y in range(top,bottom+1):
                self.setw(left,y)
                self.setw(right,y)
            for x in range(left+1,right):
                for y in range(top+1,bottom):
                    self.lockw(x,y)

    def holes(self, rng_radius, rng_e, n_holes, rng_rect):
        """Generate a set of holes in the level. It takes four args:
        0: the rng for the radius of the holes
        1: the rng for the excentricity of the holes
        2: the number of holes
        3: the rng for the shape of the hole 0 for circular, 1 for rectangular
        """
        for i in range(n_holes):
            cx = randint(0,self.WIDTH-1)
            cy = randint(0,self.HEIGHT-1)
            r = rng_radius()
            e = rng_e()*1.0
            rect = rng_rect()
            for x in range(cx-int(r*e+0.5),cx+int(r*e+0.5)+1):
                for y in range(cy-int(r/e+0.5),cy+int(r/e+0.5)+1):
                    if not rect and (((x-cx)/e)**2+((y-cy)*e)**2) > r**2:
                        continue
                    self.clrw(x,y)

    def grids(self, horizchance, vertchance):
        """Generate a level with a grid of horizontal and vertical lines
        0: gaussian chance of each horizontal line part
        1: gaussian chance of each vertical line part
        """
        self.reset(fill=False)
        xsize = choice([3,3,3,4,4,4,4,5,6])
        ysize = choice([2,3,3,4,4,4,4,5])
        xofs = choice([-1,0,1])
        yofs = choice([-1,0,1])
        for x in range((self.WIDTH/xsize)+1):
            for y in range((self.HEIGHT/ysize)+1):
                dx = x*xsize + xofs
                dy = y*ysize + yofs
                if gauss(0,1) > horizchance:
                    for i in range(0,xsize+1):
                        self.setw(dx+i,dy)
                if gauss(0,1) > vertchance:
                    for i in range(0,ysize+1):
                        self.setw(dx,dy+i)

    def pegs(self, pegchance, posadj, thick):
        """Generate a level by putting pegs
        0: gaussian level of a peg appearance
        1: gaussian level of peg position adjustment
        """
        self.reset(fill=False)
        xdist = choice([3,3,3,4,4,5]) # distance between pegs
        ydist = choice([2,3,3,3,4,5]) # distance between pegs
        if not thick:
            xdist = xdist - randint(0,1)
            ydist = ydist - randint(0,1)
        xadj = randint(0,4) - 2
        yadj = randint(0,4) - 2
        for x in range(self.WIDTH / xdist):
            for y in range(self.HEIGHT / ydist):
                if gauss(0,1) > pegchance:
                    dx = x * xdist + xadj
                    dy = y * ydist + yadj
                    if gauss(0,1) > posadj:
                        dx = dx + randint(0,2) - 1
                        dy = dy + randint(0,2) - 1
                    self.setw(dx,dy)
                    if thick:
                        self.setw(dx+1,dy)
                        self.setw(dx,dy+1)
                        self.setw(dx+1,dy+1)

    def mondrian(self, x1=2,y1=2,x2=-1,y2=-1, horiz=-1, mindepth=3):
        """Generate a level that looks a bit like a Piet Mondrian painting, or
        different sized rectangles stacked on top of each other.
        0-3: the size of the area to be split
        4: whether the first split is horizontal or vertical
        5: minimum number of splits to do
        """
        if horiz == -1:
            horiz = choice([0,1])
        if x2 == -1:
            x2 = self.WIDTH-2
        if y2 == -1:
            y2 = self.HEIGHT-2
        if (abs(x2-x1) < 6) or (abs(y2-y1) < 5):
            return
        mindepth = mindepth - 1
        if horiz == 1:
            horiz = 0
            dy = randint(y1+2,y2-2)
            for dx in range(min(x1,x2),max(x1,x2)):
                self.setw(dx,dy)
            if (random() < 0.75) or (mindepth > 0):
                self.mondrian(x1,y1,x2,dy, horiz, mindepth)
            if (random() < 0.75) or (mindepth > 0):
                self.mondrian(x1,dy,x2,y2, horiz, mindepth)
        else:
            horiz = 1
            dx = randint(x1+3,x2-3)
            for dy in range(min(y1,y2),max(y1,y2)):
                self.setw(dx,dy)
            if (random() < 0.75) or (mindepth > 0):
                self.mondrian(x1,y1,dx,y2, horiz, mindepth)
            if (random() < 0.75) or (mindepth > 0):
                self.mondrian(dx,y1,x2,y2, horiz, mindepth)

    def bouncers(self, length, diradj, rev):
        """Generate a level using a down and left or right moving walker
        0: how many steps does the walker take
        1: gaussian level, how often to change moving from left to right
        2: fill empty level with wall or reverse?
        """
        if rev == 0:
            self.reset(fill=True)
        else:
            self.reset(fill=False)
        x = randint(0,self.WIDTH-2)
        y = randint(0,self.HEIGHT-2)
        lorr = choice([1, -1])  # move left or right
        for i in range(length):
            if rev == 0:
                self.clrw(x,y)
                self.clrw(x+1,y)
                self.clrw(x,y+1)
                self.clrw(x+1,y+1)
            else:
                self.setw(x,y)
                self.setw(x+1,y)
            x = x + lorr
            y = y + 1
            if y > self.HEIGHT:
                y = 0
            if x > self.WIDTH - 2:
                x = self.WIDTH - 2
                lorr = -lorr
            elif x < 0:
                x = 0
                lorr = -lorr
            if gauss(0,1) > diradj:
                lorr = -lorr


    def walkers(self, length, minturn, maxturn, isbig):
        """Generate a level with a walker
        0: length of the walker: how many steps it walks
        1: minimum length it walks straight, before turning
        2: maximum length it walks straight, before turning
        3: is the trail is 1 or 2 blocks high
        """
        # We start from a full wall
        self.reset(fill=True)
        x = randint(0,self.WIDTH-2)
        y = randint(0,self.HEIGHT-2)
        dir = randint(0,4)
        dlen = 0
        for i in range(length):
            self.clrw(x,y)
            self.clrw(x+1,y)
            if isbig == 1:
                self.clrw(x,y+1)
                self.clrw(x+1,y+1)
            dlen = dlen + 1
            if dir == 0:
                x = x - 2
                if x < 0:
                    x = self.WIDTH-2
            elif dir == 1:
                y = y - 1
                if y < 0:
                    y = self.HEIGHT
            elif dir == 2:
                x = x + 2
                if x > (self.WIDTH - 2):
                    x = 0
            else:
                y = y + 1
                if y > self.HEIGHT:
                    y = 0
            if dlen > randint(minturn, maxturn):
                # turn 90 degrees
                dir = (dir + choice([1,3])) % 4
                dlen = 0

    def rivers(self, n_flow, side_threshold, side_shift):
        """Generate flow paths by digging a big wall. The arguments are:
        0: the number of parallel flow to dig in the wall
        1: side_threshold is a gausian level for doing a step aside
        2: side_shift is the maximal size of the side step.
        """
        # We start from a full wall
        self.reset(fill=True)
        for x in [0, self.WIDTH-2]+[randint(3,self.WIDTH-5) for f in range(max(0, n_flow-2))]:
            for y in range(self.HEIGHT):
                self.clrw(x,y)
                self.clrw(x+1,y)
                g = gauss(0,1)
                if abs(g) > side_threshold:
                    # We want to move aside, let's find which side is the best:
                    if self.WIDTH/4 < x < 3*self.WIDTH/4:
                        side = random() > 0.5
                    t = random()
                    if t > x*4/self.WIDTH:
                        side = 1
                    elif t > (self.WIDTH-x)*4/self.WIDTH:
                        side = -1
                    side_step = randint(1,side_shift)
                    if side > 0:
                        for i in range(x+2, min(x+2+side_step,self.WIDTH-1)):
                            self.clrw(i,y)
                        x = max(0,min(x+side_step, self.WIDTH-2))
                    else:
                        for i in range(max(x-side_step,0),x):
                            self.clrw(i,y)
                        x = max(x-side_step, 0)

    def platforms_reg(self):
        """Generate random platforms at regular y-intervals.
        """
        self.reset(fill=False)
        yadjs = [-2,-1,0,0,0,0,0,0,0,0,1,2]
        y = randint(2,4)
        yinc = randint(2,6)
        yincadj = choice(yadjs)
        ymax = self.HEIGHT-choice([1,1,1,1,1,2,2,2,3,3,4])-1
        while y < ymax:
            holes = randint(choice([0,1,1,1,1]),7)
            for x in range(0, self.WIDTH):
                self.setw(x,y)
            for i in range(holes):
                x = randint(0, self.WIDTH-2)
                self.clrw(x,y)
                self.clrw(x+1,y)
            y = y + yinc
            yinc = yinc + yincadj
            if yinc < 2:
                yinc = 2
                yincadj = choice(yadjs)
            if yinc > 6:
                yinc = 6
                yincadj = choice(yadjs)

    def startplatform(self):
        "Make sure there's free space with wall underneath for dragon start positions"
        hei = choice([1,1,1,2,2,3])
        lft = choice([0,1])
        wid = choice([3,3,3,4,5])
        for x in range(lft, wid):
            self.setw(x,self.HEIGHT-1)
            self.setw(self.WIDTH-x-1,self.HEIGHT-1)
            for y in range(hei+1):
                self.clrw(x,self.HEIGHT-2-y)
                self.clrw(self.WIDTH-x-1,self.HEIGHT-2-y)

    def close(self):
        "Just close the level with floor and roof"
        for x in range(self.WIDTH):
            self.setw(x,0) 
            self.setw(x,self.HEIGHT)

    def largest_vertical_hole(self, x):
        "Returns the (start, stop) of the largest range of holes in column x."
        if not (0 <= x < self.WIDTH):
            return (0, 0)
        ranges = []
        best = 0
        length = 0
        for y in range(self.HEIGHT+1):
            if y < self.HEIGHT and self.getw(x,y) == ' ':
                length += 1
            elif length > 0:
                if length > best:
                    del ranges[:]
                    best = length
                if length == best:
                    ranges.append((y-length, y))
                length = 0
        return choice(ranges or [(0, 0)])

    def dig_vertical_walls(self):
        "Check that no vertical wall spans the whole height of the level"
        vwall = []
        for x in range(self.WIDTH):
            spaces = 0
            for y in range(self.HEIGHT-1):   # ignore bottom line spaces
                spaces += self.getw(x,y) == ' '
            if spaces == 0 or (random() < 0.4**spaces):
                vwall.append(x)
        shuffle(vwall)
        for x in vwall:
            # look for the longest continuous space in each of the two
            # adjacent columns, and extend these to the current column
            def dig(y1, y2):
                for y in range(y1, y2):
                    self.clrw(x, y)
                return y1 < y2 and y1 < self.HEIGHT-1
            progress = False
            for col in [x-1, x+1]:
                y1, y2 = self.largest_vertical_hole(col)
                progress |= dig(y1, y2)
            while not progress:
                progress |= dig(randint(0, self.HEIGHT-1),
                                randint(0, self.HEIGHT-1))

    def prevent_straight_fall(self):
        """Make platforms that prevent falling straight from top to bottom, but
        still leave space for moving.
        """
        falls = []
        for x in range(self.WIDTH):
            for y in range(self.HEIGHT):
                if self.getw(x,y) == '#':
                    break
            else:
                falls = falls + [x]
        y = oldy = -10
        for x in falls:
            while (y < oldy+2) and (y > oldy-2):
                y = randint(2, self.HEIGHT-2)
            for dy in range(y-1,y+2):
                for dx in range(x-3, x+4):
                    self.clrw(dx,dy)
            self.setw(x-1,y)
            self.setw(x+1,y)
            self.setw(x,y)
            oldy = y

    def do_monsters(self):
        """Create monsters based on the requested settings.
        mlist is a list of monster setting. Each item is a tuple with:
        0: the list of monster to uses (each item might be a tuple)
        1: the rng for the number of monsters to pick in the list.
        """
        current = 'a'
        for ms in self.mlist:
            n_monsters = ms[1]()
            for idx in range(n_monsters):
                self.__class__.__dict__[current] = choice(ms[0])
                ntry = self.MAXTRY
                while ntry:
                    x = randint(0,self.WIDTH-2)
                    y = randint(0,self.HEIGHT-1)

                    if self.getw(x,y) == self.getw(x+1,y) == ' ':
                        self.wmap[y][x] = current
                        break
                    ntry -= 1
                current = chr(ord(current)+1)

    def do_walls(self):
        "Build the actual walls map for the game."
        self.__class__.walls = ''
        for y in range(self.HEIGHT-1):
            self.__class__.walls += '##'
            for x in range(self.WIDTH):
                self.__class__.walls += self.wmap[y][x]
            self.__class__.walls += '##\n'
        self.__class__.walls += '##'
        for x in range(self.WIDTH):
            if self.getw(x,0) == '#' or self.getw(x,self.HEIGHT-1) == '#':
                self.__class__.walls += '#'
            else:
                self.__class__.walls += ' '
        self.__class__.walls += '##\n'

    def do_winds(self):
        "Build the actual wind map for the game."
        self.__class__.winds = ''
        for y in range(self.HEIGHT):
            self.__class__.winds += '>>'
            for x in range(self.WIDTH):
                self.__class__.winds += self.windmap[y][x]
            self.__class__.winds += '<<' + '\n'

    def do_bonuses(self):
        self.__class__.letter    = choice([0,1])
        self.__class__.fire      = choice([0,1])
        self.__class__.lightning = choice([0,1])
        self.__class__.water     = choice([0,1])
        self.__class__.top       = choice([0,1])

    def generate(self):
        "Generate random level settings."
        assert 0, "--- THIS IS NO LONGER REALLY USED ---"
        self.mlist = [([
            LNasty, LMonky, LGhosty, LFlappy, LSpringy, LOrcy, LGramy, LBlitzy,
            RNasty, RMonky, RGhosty, RFlappy, RSpringy, ROrcy, RGramy, RBlitzy,
            ],lambda : flat(12,4))]
        gens = choice([512,512,256,256,128,128,64,64,32,32,16,16,16,16,16,16,20,20,8,8,8,8,4,4,4,4,2,2,2,2,1,1,3,5,6,7])
        self.genwalls = []
        if gens & 512:
            print 'Using grids generator'
            self.genwalls.append((RandomLevel.grids,
                                  uniform(0.0, 0.1),
                                  uniform(0.0, 0.1)))
        if gens & 256:
            # generate using pegs
            print 'Using the pegs generator'
            self.genwalls.append((RandomLevel.pegs,
                                  uniform(0.1,0.2),
                                  uniform(0.45,0.7),
                                  choice([0,1,1,1])))
        if gens & 128:
            # generate using a bouncer
            nr = choice([0,0,1])
            print 'Using the bouncer generator'
            self.genwalls.append((RandomLevel.bouncers,
                                 dice(1, 100) + 250 - nr*200, # length
                                 uniform(0.7, 1.7),
                                 nr))
        if gens & 64:
            # generate using a walker
            print 'Using the walker generator'
            nr = dice(1, 3) + 2
            self.genwalls.append((RandomLevel.walkers,
                                 dice(2, 100) + 100, # length
                                 nr, nr + dice(2, 3), # straight walk min, max len
                                 choice([0,1])))
        if gens & 32:
            # generate rivers
            print 'Using the rivers generator'
            self.genwalls.append((RandomLevel.rivers,
                                  randrange(2,(self.WIDTH-4)/5),    # the number of rivers
                                  uniform(0.7, 1.7), # the side stepping threshold
                                  6))                # the max side stepping size
        if gens & 16:
            # generate rooms
            print 'Using the romms generator'
            nr = choice([1,2,2,2,3,3,4,5])
            self.genwalls.append((RandomLevel.rooms,
                                  lambda : flat(9-nr,2),    # the half size of the room
                                  lambda : uniform(0.8,1.2), # the excentricity of the room
                                  nr))                       # the number of rooms
        if gens & 8:
            # generate a holes generator
            # as this is interesting only if the level is filled somehow
            print 'Using the holes generator'
            self.genwalls.append((RandomLevel.mess,1-uniform(0.2,0.5)))
            nh = choice([1,1,2,2,2,3,3,3,4,5])
            self.genwalls.append((RandomLevel.holes,
                                  lambda : flat(9-nh,2),       # radius of the holes
                                  lambda : uniform(0.9,1.1),   # excentricity
                                  nh,                          # number of holes
                                  lambda : choice([0,0,0,1]))) # circle or rectangle
        if gens & 4:
            # generate a lines generator
            print 'Using the lines generator'
            self.genwalls.append((RandomLevel.lines,
                                  lambda : dice(7,3), # line length
                                  dice(2,3)))         # number of lines
        if gens & 2:
            # generate a platforms generator
            print 'Using the platforms generator'
            nplat  = dice(2,4,0)
            if nplat: space  = flat((self.HEIGHT-1)/nplat/2,(self.HEIGHT-1)/nplat/2-1)
            else:     space = 1
            nholes = lambda : dice(1,3,0)          
            wholes = lambda : dice(2,3)
            full = randrange(2)
            self.genwalls.append((RandomLevel.platforms,
                                  (nplat,space),   # number of platform and spacing
                                  (nholes,wholes), # number of holes and width
                                  full))           # full width platform
        if gens & 1:
            # generate a mess generator
            print 'Using the mess generator'
            if gens & ~2:
                offset = 0
                scale = 0.05
            else:
                offset = 0.05
                scale = 0.10
            self.genwalls.append((RandomLevel.mess,offset+random()*scale))
        if random() < 0.2:
            self.genwalls.append((RandomLevel.close,))
        if random() < 0.90:
            self.genwalls.append((RandomLevel.startplatform,))
        self.genwalls.append((RandomLevel.generate_wind, ))


Levels = []
for i in range(25):
    class level(RandomLevel):
        auto = 1
    Levels.append(level)

class levelfinal(RandomLevel):
    genwalls = [(RandomLevel.platforms,(4,3),(lambda:flat(1,1),lambda:flat(4,2)),1)]
Levels.append(levelfinal)
