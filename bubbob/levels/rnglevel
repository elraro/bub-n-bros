from random import *
from math import *

import boarddef
from boarddef import LNasty, LMonky, LGhosty, LFlappy
from boarddef import LSpringy, LOrcy, LGramy, LBlitzy
from boarddef import RNasty, RMonky, RGhosty, RFlappy
from boarddef import RSpringy, ROrcy, RGramy, RBlitzy

def flat(mean,var):
    return randrange(mean-var,mean+var+1)

def dice(n,sides,orig=1):
    result = 0
    for i in range(n):
        result += orig+randrange(sides)
    return result

def fish(mu):
    def fact(n):
        r = 1.
        for i in range(1,n+1):
            r *= i
        return r
    scale = fact(0)/exp(-mu)
    dens = []
    while 1:
        x = len(dens)
        dens.append(int(scale*exp(-mu)*pow(mu,x)/fact(x)+0.5))
        if x > mu and dens[-1] == 0:
            break
    table = []
    x = 0
    for d in dens:
        for i in range(d):
            table.append(x)
        x += 1
    return choice(table)


class RandomLevel(boarddef.Level):
    WIDTH  = 32
    HEIGHT = 28
    MAXTRY = 1000
    # parameters of the 'mess generator'
    # mess_prob : the probability that a cell turn into a wall

    def __init__(self,num):
        if hasattr(self.__class__, 'walls'):
            #print 'Reusing previously generated level'
            #print self.__class__.walls
            self.walls = self.__class__.walls
            boarddef.Level.__init__(self,num)
            return

        #print 'Generating a new level'

        # map for the walls
        self.wmap = [ [' ' for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        # map of the free cells
        self.fmap = [ [1 for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]

        self.windmap = [ [' ' for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]

        if hasattr(self, 'auto'):
            self.generate()
            self.do_bonuses()

        for gw in self.genwalls:
            gw[0](self,*gw[1:])

        if hasattr(self, 'mlist'):
            self.do_monsters()

        self.dig_vertical_walls()
        self.do_walls()
        self.walls = self.__class__.walls
        #print self.walls

        self.do_winds()
        self.winds = self.__class__.winds

        boarddef.Level.__init__(self,num)

    def setw(self,x,y,c='#'):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return
        if self.fmap[y][x]:
            self.wmap[y][x] = c
            self.fmap[y][x] = 0

    def clrw(self,x,y):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return
        self.wmap[y][x] = ' '
        self.fmap[y][x] = 1

    def setwind(self,x,y,c=' '):
        if x > self.WIDTH-1 or x < 0 or y > self.HEIGHT-1 or y < 0:
            return
        self.windmap[y][x] = c

    def generate_wind1(self, rndchoice=1, choices=[' ',' ',' ','x','>','<','^','^','v'], xsize=-1,ysize=-1):
        """Makes a random wind pattern. Parameters:
        0: if 1=randomly select from choices, else select in order
        1: a list of the choices that are allowed.
        2: horizontal size of wind blocks
        3: vertical size of wind blocks
        """
        choicenum = 0
        if xsize == -1:
            xsize = randint(1, self.WIDTH)
        if ysize == -1:
            ysize = randint(1, self.HEIGHT)
        if xsize < 1:
            xsize = 1
        elif xsize > self.WIDTH:
            xsize = self.WIDTH
        if ysize < 1:
            ysize = 1
        elif ysize > self.HEIGHT:
            ysize = self.HEIGHT
        for x in range((self.WIDTH/xsize)+1):
            for y in range((self.HEIGHT/ysize)+1):
                if rndchoice == 1:
                    wdir = choice(choices)
                else:
                    wdir = choices[choicenum]
                    choicenum = (choicenum + 1) % len(choices)
                for dx in range(xsize+1):
                    for dy in range(ysize+1):
                        self.setwind(x+dx,y+dy,wdir)
        # make sure that the special bubbles can come into screen
        for x in range(self.WIDTH):
            self.setwind(x, 0, ' ')
            self.setwind(x, self.HEIGHT-1, ' ')

    def wind_sidewalls(self):
        """Make sure the left and side walls have updraft next to them
        """
        for y in range(self.HEIGHT):
            self.setwind(0,y,'^')
            self.setwind(self.WIDTH-1,y,'^')

    def generate_wind(self):
        """Chooses one of the wind pattern generators and uses that to generate the winds.
        """
        gens = choice([1,1,2,3,4,4,4,4,5])
        if gens == 1: # totally random pattern
            self.generate_wind1()
        elif gens == 2: # wind "layers"
            self.generate_wind1(0, ['x','^','^','^'],self.WIDTH,1)
            self.wind_sidewalls()
        elif gens == 3: # "wiggly" winds
            self.generate_wind1(1, ['^','<','^','>'],1,1)
            self.wind_sidewalls()
        elif gens == 4: # "normal" wind pattern
            self.wind_sidewalls()
            dx = (self.WIDTH/2)
            for x in range(dx-3, dx+3):
                self.setwind(x,2,'x')
            for x in range(dx-2):
                self.setwind(x,2,'>')
                self.setwind(self.WIDTH-x,2,'<')
        elif gens == 5: # bubbles are stopped by horizontal walls
            self.wind_sidewalls()
            for x in range(self.WIDTH):
                for y in range(self.HEIGHT-2):
                    if self.wmap[y][x] == '#':
                        if self.wmap[y+1][x] == ' ':
                            self.setwind(x,y+1,'x')

    def mess(self, threshold):
        """Random fill of the board with walls.
        Only one argument, the probability that
        a cell turns out to be a wall.
        """
        for x in range(self.WIDTH):
            for y in range(self.HEIGHT):
                if random() < threshold:
                    self.setw(x,y)

    def platforms(self, (nplat, space), (rng_holes, rng_width), full=1):
        """Place random platforms.
        args is a tuple with the following fields:
        0: a tuple containing the number of platforms and
           the minum space between two platforms,
        1: a tuple indicating in order:
           - the rng for the number of holes per platform
           - the rng for the width of the holes,
        2: a flag indicating whether the platform should cross
           the whole level or not.
        """
        plat = []
        for i in range(nplat):
            ntry = 100
            while ntry:
                y = randint(0,self.HEIGHT-1)
                found = 0
                for old in plat:
                    if abs(old-y) <= space:
                        found = 1
                        break
                if not found:
                    plat.append(y)
                    break
                ntry -= 1
            if not ntry:
                continue  # ignore platform
            if full:
                x = 0
                w = self.WIDTH
            else:
                x = randint(0,self.WIDTH-1)
                w = randint(0,self.WIDTH-1)
                s = choice([-1,1])
                if s == -1:
                    w = min(w,x)
                    x -= w
                else:
                    w = min(w,self.WIDTH-x)
            for x1 in range(x,x+w):
                self.setw(x1,y)
            for i in range(rng_holes()):
                hx = randint(x,x+w)
                hw = rng_width()
                for h in range(hx-hw/2,hx+hw/2):
                    self.clrw(h,y)

    def lines(self, rng_len, nlines, rng_angle=None):
        """Generate a set of lines in any direction. It takes three
        arguments, a rng for the length the lines, the number of lines,
        and a rng for the angle.
        """
        if rng_angle is None:
            rng_angle = lambda : choice([0]+[pi/i for i in range(3,21)]+[-pi/i for i in range(3,21)])
        for i in range(nlines):
            len = rng_len()
            angle = rng_angle()
            ntry = self.MAXTRY
            while ntry:
                sx = randint(0,self.WIDTH-1)
                sy = randint(0,self.HEIGHT-1)
                dx = int(sx + len*cos(angle) + 0.5)
                dy = int(sy + len*sin(angle) + 0.5)
                if dx < self.WIDTH and dy < self.HEIGHT and dx >= 0 and dy >= 0:
                    break
                ntry -= 1
            if ntry == 0:
                break
            if abs(dx-sx) > abs(dy-sy):
                for x in range(dx-sx+1):
                    y = (2*(dy-sy)*x/(dx-sx)+1)/2
                    self.setw(sx+x,sy+y)
            else:
                for y in range(dy-sy+1):
                    x = (2*(dx-sx)*y/(dy-sy)+1)/2
                    self.setw(sx+x,sy+y)

    def rooms(self, rng_radius, rng_e, n_rooms):
        """Generate rooms. It takes the following arguments:
        0: the rng for the radius of the room
        1: the rng for the excentricity of the room
        2: the number of rooms
        """
        for i in range(n_rooms):
            cx = randint(0,self.WIDTH-1)
            cy = randint(0,self.HEIGHT-1)
            r = rng_radius()
            e = rng_e()*1.0
            left   = cx-int(r*e+0.5)
            right  = cx+int(r*e+0.5)
            top    = cy-int(r/e+0.5)
            bottom = cy+int(r/e+0.5)
            for x in range(left,right+1):
                self.setw(x,top)
                self.setw(x,bottom)
            for y in range(top,bottom+1):
                self.setw(left,y)
                self.setw(right,y)
            for x in range(left+1,right):
                for y in range(top+1,bottom):
                    if x > 0 and x < self.WIDTH-1 and y > 0 and y < self.HEIGHT-1:
                        self.fmap[y][x] = 0

    def holes(self, rng_radius, rng_e, n_holes, rng_rect):
        """Generate a set of holes in the level. It takes four args:
        0: the rng for the radius of the holes
        1: the rng for the excentricity of the holes
        2: the number of holes
        3: the rng for the shape of the hole 0 for circular, 1 for rectangular
        """
        for i in range(n_holes):
            cx = randint(0,self.WIDTH-1)
            cy = randint(0,self.HEIGHT-1)
            r = rng_radius()
            e = rng_e()*1.0
            rect = rng_rect()
            for x in range(cx-int(r*e+0.5),cx+int(r*e+0.5)+1):
                for y in range(cy-int(r/e+0.5),cy+int(r/e+0.5)+1):
                    if not rect and (((x-cx)/e)**2+((y-cy)*e)**2) > r**2:
                        continue
                    self.clrw(x,y)

    def grids(self, horizchance, vertchance):
        """Generate a level with a grid of horizontal and vertical lines
        0: gaussian chance of each horizontal line part
        1: gaussian chance of each vertical line part
        """
        self.wmap = [ [ ' ' for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        self.fmap = [ [ 1 for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        xsize = choice([3,3,3,4,4,4,4,5,6])
        ysize = choice([2,3,3,4,4,4,4,5])
        xofs = choice([-1,0,1])
        yofs = choice([-1,0,1])
        for x in range((self.WIDTH/xsize)+1):
            for y in range((self.HEIGHT/ysize)+1):
                dx = x*xsize + xofs
                dy = y*ysize + yofs
                if gauss(0,1) > horizchance:
                    for i in range(0,xsize+1):
                        self.setw(dx+i,dy)
                if gauss(0,1) > vertchance:
                    for i in range(0,ysize+1):
                        self.setw(dx,dy+i)

    def pegs(self, pegchance, posadj, thick):
        """Generate a level by putting pegs
        0: gaussian level of a peg appearance
        1: gaussian level of peg position adjustment
        """
        self.wmap = [ [ ' ' for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        self.fmap = [ [ 1 for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        xdist = choice([3,3,3,4,4,5]) # distance between pegs
        ydist = choice([2,3,3,3,4,5]) # distance between pegs
        if not thick:
            xdist = xdist - randint(0,1)
            ydist = ydist - randint(0,1)
        xadj = randint(0,4) - 2
        yadj = randint(0,4) - 2
        for x in range(self.WIDTH / xdist):
            for y in range(self.HEIGHT / ydist):
                if gauss(0,1) > pegchance:
                    dx = x * xdist + xadj
                    dy = y * ydist + yadj
                    if gauss(0,1) > posadj:
                        dx = dx + randint(0,2) - 1
                        dy = dy + randint(0,2) - 1
                    self.setw(dx,dy)
                    if thick:
                        self.setw(dx+1,dy)
                        self.setw(dx,dy+1)
                        self.setw(dx+1,dy+1)

    def bouncers(self, length, diradj, rev):
        """Generate a level using a down and left or right moving walker
        0: how many steps does the walker take
        1: gaussian level, how often to change moving from left to right
        2: fill empty level with wall or reverse?
        """
        if rev == 0:
            wll = '#'
        else:
            wll = ' '
            rev = 1
        self.wmap = [ [ wll for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        self.fmap = [ [ rev for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        x = randint(0,self.WIDTH-2)
        y = randint(0,self.HEIGHT-2)
        lorr = choice([1, -1])  # move left or right
        for i in range(length):
            if rev == 0:
                self.clrw(x,y)
                self.clrw(x+1,y)
                self.clrw(x,y+1)
                self.clrw(x+1,y+1)
            else:
                self.setw(x,y)
                self.setw(x+1,y)
            x = x + lorr
            y = y + 1
            if y > self.HEIGHT:
                y = 0
            if x > self.WIDTH - 2:
                x = self.WIDTH - 2
                lorr = -lorr
            elif x < 0:
                x = 0
                lorr = -lorr
            if gauss(0,1) > diradj:
                lorr = -lorr


    def walkers(self, length, minturn, maxturn, isbig):
        """Generate a level with a walker
        0: length of the walker: how many steps it walks
        1: minimum length it walks straight, before turning
        2: maximum length it walks straight, before turning
        3: is the trail is 1 or 2 blocks high
        """
        # all solid map
        self.wmap = [ ['#' for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        self.fmap = [ [ 0 for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        x = randint(0,self.WIDTH-2)
        y = randint(0,self.HEIGHT-2)
        dir = randint(0,4)
        dlen = 0
        for i in range(length):
            self.clrw(x,y)
            self.clrw(x+1,y)
            if isbig == 1:
                self.clrw(x,y+1)
                self.clrw(x+1,y+1)
            dlen = dlen + 1
            if dir == 0:
                x = x - 2
                if x < 0:
                    x = self.WIDTH-2
            elif dir == 1:
                y = y - 1
                if y < 0:
                    y = self.HEIGHT
            elif dir == 2:
                x = x + 2
                if x > (self.WIDTH - 2):
                    x = 0
            else:
                y = y + 1
                if y > self.HEIGHT:
                    y = 0
            if dlen > randint(minturn, maxturn):
                # turn 90 degrees
                dir = (dir + choice([1,3])) % 4
                dlen = 0

    def rivers(self, n_flow, side_threshold, side_shift):
        """Generate flow paths by digging a big wall. The arguments are:
        0: the number of parallel flow to dig in the wall
        1: side_threshold is a gausian level for doing a step aside
        2: side_shift is the maximal size of the side step.
        """
        # We start from a full wall
        # map for the walls
        self.wmap = [ ['#' for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        # map of the free cells
        self.fmap = [ [0 for x in range(self.WIDTH)] for y in range(self.HEIGHT) ]
        for x in [0, self.WIDTH-2]+[randint(3,self.WIDTH-5) for f in range(max(0, n_flow-2))]:
            for y in range(self.HEIGHT):
                self.clrw(x,y)
                self.clrw(x+1,y)
                g = gauss(0,1)
                if abs(g) > side_threshold:
                    # We want to move aside, let's find which side is the best:
                    if self.WIDTH/4 < x < 3*self.WIDTH/4:
                        side = random() > 0.5
                    t = random()
                    if t > x*4/self.WIDTH:
                        side = 1
                    elif t > (self.WIDTH-x)*4/self.WIDTH:
                        side = -1
                    side_step = randint(1,side_shift)
                    if side > 0:
                        for i in range(x+2, min(x+2+side_step,self.WIDTH-1)):
                            self.clrw(i,y)
                        x = max(0,min(x+side_step, self.WIDTH-2))
                    else:
                        for i in range(max(x-side_step,0),x):
                            self.clrw(i,y)
                        x = max(x-side_step, 0)

    def close(self):
        "Just close the level with floor and roof"
        for x in range(self.WIDTH):
            self.setw(x,0) 
            self.setw(x,self.HEIGHT)

    def dig_vertical_walls(self):
        "Check that no vertical wall spans the whole height of the level"
        vwall = []
        for x in range(self.WIDTH):
            for y in range(self.HEIGHT):
                if self.wmap[y][x] == ' ':
                    break
            else:
                vwall.append(x)
        for x in vwall:
            for y in range(0,self.HEIGHT,randint(2,4)):
                self.clrw(x,y)
                for dx in range(-1,2):
                    for dy in range(-1,2):
                        if choice([0,1]) == 0:
                            self.clrw(x+dx,y+dy)

    def do_monsters(self):
        """Create monsters based on the requested settings.
        mlist is a list of monster setting. Each item is a tuple with:
        0: the list of monster to uses (each item might be a tuple)
        1: the rng for the number of monsters to pick in the list.
        """
        from string import ascii_letters
        current = 'a'
        for ms in self.mlist:
            n_monsters = ms[1]()
            for idx in range(n_monsters):
                self.__class__.__dict__[current] = choice(ms[0])
                ntry = self.MAXTRY
                while ntry:
                    x = randint(0,self.WIDTH-2)
                    y = randint(0,self.HEIGHT-1)

                    if self.wmap[y][x] == self.wmap[y][x+1] == ' ':
                        self.wmap[y][x] = current
                        break
                    ntry -= 1
                current = chr(ord(current)+1)

    def do_walls(self):
        "Build the actual walls map for the game."
        self.__class__.walls = ''
        for y in range(self.HEIGHT-1):
            self.__class__.walls += '##'
            for x in range(self.WIDTH):
                self.__class__.walls += self.wmap[y][x]
            self.__class__.walls += '##\n'
        self.__class__.walls += '##'
        for x in range(self.WIDTH):
            if self.wmap[0][x] == '#' or self.wmap[self.HEIGHT-1][x] == '#':
                self.__class__.walls += '#'
            else:
                self.__class__.walls += ' '
        self.__class__.walls += '##\n'

    def do_winds(self):
        "Build the actual wind map for the game."
        self.__class__.winds = ''
        for y in range(self.HEIGHT):
            self.__class__.winds += '>>'
            for x in range(self.WIDTH):
                self.__class__.winds += self.windmap[y][x]
            self.__class__.winds += '<<' + '\n'

    def do_bonuses(self):
        self.__class__.letter    = choice([0,1])
        self.__class__.fire      = choice([0,1])
        self.__class__.lightning = choice([0,1])
        self.__class__.water     = choice([0,1])
        self.__class__.top       = choice([0,1])

    def generate(self):
        "Generate random level settings."
        self.mlist = [([
            LNasty, LMonky, LGhosty, LFlappy, LSpringy, LOrcy, LGramy, LBlitzy,
            RNasty, RMonky, RGhosty, RFlappy, RSpringy, ROrcy, RGramy, RBlitzy,
            ],lambda : flat(12,4))]
        gens = choice([512,512,256,256,128,128,64,64,32,32,16,16,16,16,16,16,20,20,8,8,8,8,4,4,4,4,2,2,2,2,1,1,3,5,6,7])
        self.genwalls = []
        if gens & 512:
            print 'Using grids generator'
            self.genwalls.append((RandomLevel.grids,
                                  uniform(0.0, 0.1),
                                  uniform(0.0, 0.1)))
        if gens & 256:
            # generate using pegs
            print 'Using the pegs generator'
            self.genwalls.append((RandomLevel.pegs,
                                  uniform(0.1,0.2),
                                  uniform(0.45,0.7),
                                  choice([0,1,1,1])))
        if gens & 128:
            # generate using a bouncer
            nr = choice([0,0,1])
            print 'Using the bouncer generator'
            self.genwalls.append((RandomLevel.bouncers,
                                 dice(1, 100) + 250 - nr*200, # length
                                 uniform(0.7, 1.7),
                                 nr))
        if gens & 64:
            # generate using a walker
            print 'Using the walker generator'
            nr = dice(1, 3) + 2
            self.genwalls.append((RandomLevel.walkers,
                                 dice(2, 100) + 100, # length
                                 nr, nr + dice(2, 3), # straight walk min, max len
                                 choice([0,1])))
        if gens & 32:
            # generate rivers
            print 'Using the rivers generator'
            self.genwalls.append((RandomLevel.rivers,
                                  randrange(2,(self.WIDTH-4)/5),    # the number of rivers
                                  uniform(0.7, 1.7), # the side stepping threshold
                                  6))                # the max side stepping size
        if gens & 16:
            # generate rooms
            print 'Using the romms generator'
            nr = choice([1,2,2,2,3,3,4,5])
            self.genwalls.append((RandomLevel.rooms,
                                  lambda : flat(9-nr,2),    # the half size of the room
                                  lambda : uniform(0.8,1.2), # the excentricity of the room
                                  nr))                       # the number of rooms
        if gens & 8:
            # generate a holes generator
            # as this is interesting only if the level is filled somehow
            print 'Using the holes generator'
            self.genwalls.append((RandomLevel.mess,1-uniform(0.2,0.5)))
            nh = choice([1,1,2,2,2,3,3,3,4,5])
            self.genwalls.append((RandomLevel.holes,
                                  lambda : flat(9-nh,2),       # radius of the holes
                                  lambda : uniform(0.9,1.1),   # excentricity
                                  nh,                          # number of holes
                                  lambda : choice([0,0,0,1]))) # circle or rectangle
        if gens & 4:
            # generate a lines generator
            print 'Using the lines generator'
            self.genwalls.append((RandomLevel.lines,
                                  lambda : dice(7,3), # line length
                                  dice(2,3)))         # number of lines
        if gens & 2:
            # generate a platforms generator
            print 'Using the platforms generator'
            nplat  = dice(2,4,0)
            if nplat: space  = flat((self.HEIGHT-1)/nplat/2,(self.HEIGHT-1)/nplat/2-1)
            else:     space = 1
            nholes = lambda : dice(1,3,0)          
            wholes = lambda : dice(2,3)
            full = randrange(2)
            self.genwalls.append((RandomLevel.platforms,
                                  (nplat,space),   # number of platform and spacing
                                  (nholes,wholes), # number of holes and width
                                  full))           # full width platform
        if gens & 1:
            # generate a mess generator
            print 'Using the mess generator'
            if gens & ~2:
                offset = 0
                scale = 0.05
            else:
                offset = 0.05
                scale = 0.10
            self.genwalls.append((RandomLevel.mess,offset+random()*scale))
        if random() < 0.2:
            self.genwalls.append((RandomLevel.close,))
        self.genwalls.append((RandomLevel.generate_wind, ))


Levels = []
for i in range(25):
    class level(RandomLevel):
        auto = 1
    Levels.append(level)

class levelfinal(RandomLevel):
    genwalls = [(RandomLevel.platforms,(4,3),(lambda:flat(1,1),lambda:flat(4,2)),1)]
Levels.append(levelfinal)
